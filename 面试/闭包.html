<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        /*
        * 闭包就是可以访问另一个函数的内部变量
        * 优点: 避免全局污染
        * 缺点: 父函数执行完内存不会释放。会造成内存泄漏问题
        * 作用域: 就是变量和函数的作用范围。 在哪有效。 在哪无效。 谁可以访问调用, 谁不可以访问调用
        * es6 之前只有全局作用域和局部作用域(函数作用域) es6增加了块级作用域 let
        * 作用域链: 
        * js 中的函数运行在他们被定义的作用域里, 而不是被调用的作用域里
        * this 指向问题
        */
        function fun1 () {
            var name = 1
            return function () {
                name++
                return name
            }
        }
        var getNanme = fun1()
        console.log(getNanme())
        console.log(getNanme())
        // // 闭包与for循环
        // for (var i = 0; i < 10; i++) {
        //    var arr  = []
        //    arr[i] = function() {
        //        return function () {
        //            return i 
        //        }
        //    }(i)
        //    return arr
        // }
        //10
        // for (var i = 0; i < 10; i++) {
        //    var arr  = []
        //    (function() {
        //     arr[i] = function() {
        //         return i
        //     }
        //    })(i)
        //    return arr
        // }
        //10
        // es6  //let const  try catch 也会创建块级作用域
        /*
        * 闭包中的this指向问题
        * 
        */
        var obj = {
            name: '张三',
            getNanme: function() {
                return function () {
                    console.log(this.name) //
                }
            }
        }
        obj.getNanme()() // this指向window
        /*
        * 闭包和函数柯里化的比较
        */
    </script>
</body>
</html>