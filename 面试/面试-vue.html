Vue: 归根结底他是一个对象!!! (构造函数)


1: 事件驱动

2: v-model的实现原理
    v-model 其实是个语法糖 v-bind:value v-on:input
    addProp(el, 'value', `(${value})`)
    addHandler(el, event, code, null, true)
    通过修改AST元素给el增加一个 props属性:value
    addHandler给el 增加一个处理事件 @input="input"
    data.props = {
        value: (message),
      }
    data.on = {
        input: function ($$v) {
          message=$$v
        }
      } 

3: Object.defineProperty(object, '')
4: vue中的数组方法 push pop shift unshift sort reverse  vue 通过原形拦截的方法对 这几个方法进行了重写，
5: nextTick
6: vue 中 组件的data 为什么必须是函数。 防止和其他实例公用data 属性
    data 要是是个对象的话。data上的值会被所有实例共享
    组册组件的实质就是建立一个组件构造引用。使用组件的时候才是真正创建一个组件的实例
7: keep-alive 实现原理和缓存策略
8: vue.extend()
9: vue.$set()  
    由于vue 会在初始化实例的时候把属性都变身响应式的
     执行getter setter 方法 set() 方法内部执行了defineReactive 
     用来给新加属性添加setter、getter 把它变成响应式
10: vue版本区别
   runtime-only: 只保留运行时需要。不承担模板编译工作 需要借助vue-loader去编译模板
   runtime-complier: 可以处理模板。承担编译工作
   $mount(el:'#app'): 挂载
   render函数:  有模板转换而来
   render 函数再转化为vnode 然后调用update函数更新视图
11: spa单页面的理解
   仅在页面初始化的时候加载 html js css 文件。
   一但页面加载完成spa 不会因为用户的操作而刷新页面。利用路由机制进行内容的更新
   优点: 体验好、比较快、避免页面刷新 重复跳转和
   缺点: 初次加载耗时比较多。 不能使用浏览器的前进 后退 可以使用$route.go()
   seo不友好
12: v-show 和 v-if的区别
    v-show 隐藏dom元素。display: none。不管条件是什么元素总会被渲染
    v-if: 移除dom元素。 会把条件块内的事件监听器和子组件适当的销毁。如果条件一开始就为false, 则什么也不做。true 的时候才会去渲染条件块内的元素渲染
13: 怎么理解vue的单项数据流
    数据只能有父组件向自组件传递。 不能有子组件向父组件传递。 prop 值在自组件内不允许被修改。
    自组件可以调用$emit向父组件派发一个自定义事件。父组件接受后由父组件进行修改。
14: computed watch 的区别。
    依赖其他值的变化计算生成新的值。有缓存、只有他的依赖值发生变化的时候 computed才会重新计算。
    watch 数据监听的回调。监听的值发生变化后执行回调进行业务操作。
15: vue对数组的操作
    push pop shift unshift reverse splice
16: vue 生命周期
17: $mount 做了哪些事情
18: keep-alive
    可以是被包含的组件保留状态(缓存)、避免重新渲染
    其实就是对被包在keep-alive里面的组件做了一个缓存
19: vue组件中的通信方式
    props $emit 父子通信
    $attrs $listeners 隔代通信
    $eventBus ($emit, $on) 父子、隔代、兄弟
    provide / inject  祖先组件通过provide 提供变量。子孙组件通过inject注入变量。主动提供和依赖注入
    vuex: 变量管理 父子、隔代、兄弟
20: vue-router的几种模式， vue-router的实现
      1:history hash abstract
      几种模式的区别:
      1:hash模式 路由中的# hash 虽然出现在url中 但是不会包括在请求中、对后端完全没有影响。 hash改变也不会重新加载页面
        通过监听hashchange 触发回调
        window.addEventListener('hashchange', function() {
            console.log('111')
        },false)
      2:history 模式 // 暂时还没弄太懂啊哥哥
        原理就是调用history.pushState
        跳转的时候监听popstate
21: require.context做自动化引入