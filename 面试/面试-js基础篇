1:原型链 构造函数
2:作用域
3:闭包
4:深克隆
5:基本类型、引用类型
6:内存泄漏和垃圾回收
    【1】: 标记清除 常用
        运行时会给所有变量加标记、 标记进入环境了。 变量或者函数执行完后会标记离开环境
    【2】: 引用计数
    【】 全局变量会引起内存泄漏
7:变量声明提升
8:构造函数
9:对象、实例
10:作用域
11:new 运算符的执行过程
    var obj = {  }
        obj.__proto__ = fun.prototype
        fn.call(obj)    
12:null 和 undefined 的 区别
13:instanceof 原理
    instanceof 判断一个对象或者一个方法 来自哪个构造函数
    obj.__proto__ === Function.prototype
14:代码复用 继承 函数封装(一个函数完成一个简单的功能) 把做什么和怎么做分开 apply mixin
    柯里化
15: 继承、原形链继承
16: 类型转换
17: valueOf
19: 模块化
20: es6: import / export
    commonjs: require / module.exports / exports
    amd: require / defined
21: 防抖:将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可
22: 截流:每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可
23: this 指向问题
24: ast 语法数
25: babel编译原理
    babylon 将 ES6/ES7 代码解析成 AST
    babel-traverse 对 AST 进行遍历转译，得到新的 AST
    新 AST 通过 babel-generator 转换成 ES5
26: 函数柯里化
27: 数组 map filter forEach every sort reverse some slice splice split reduce  二维数组拍平
28: 输入url的整个过程
29: documentFragment
30: localStorage 、 sessionStorage cookie
31: 实现bind call apply

-----------------------------------------
   1:call apply bind
        解: 改变函数执行时候的上下文 或者说是改变this指向。 复用
        call(this, args1, args2, args3) // 会立即执行
        apply(this, [args1, args2, args3]) // 会立即执行
        bind(this)// 不会立即执行、 返回一个函数
   1:怎么利用call、apply来求一个数组中最大或者最小值
        Math.max.apply(Math, [2,43,31,45])
        Math.min.apply(Math, [2,43,31,45])
        Math.max.call(Math, ...[2,43,31,45])
        Math.min.call(Math, ...[2,43,31,45])
   2:如何利用call、apply来做继承
        构造函数继承
        Person.call(this)
   3:转化为伪数组
        Array.prototype.sclie.call(argsment)    
   4:数组追加
        [].push.apply(arr1, arr2)
   5: 检测类型
        Object.prototype.toSring.call()  '[object, Object]'
   3:apply、call、bind的区别和主要应用场景
2: Object.create
    /*
    * 复制对象到其原型上
    */
3: Object.assign(target, sources)
    /*
    * Object.assgin()
    * 浅克隆
    * 不会克隆继承过来的属性和方法
    * target为目标对象
    * sources为源对象
    */
4: Object.keys()  只遍历自身属性。hasOwnProperty只查找自身属性、不遍历原型链上到属性 for in 会遍历全部属性
5: valueOf, toSring 
    valueOf: 返回对象原始值的表示  *暂时还没理解太透彻
    toSring: 返回对象的字符串表示
    + 作为链接符的时候 会调用toString
    + 作为运算符的时候 会调用Number 转化然后相加 null undefined Boolean  会默认调用Number
      如果有一边确定为字符串的时候默认调用toString方法
6: 作用域和闭包
    闭包: 可以访问另一个函数内部变量
    作用域:子函数可以访问父函数的内部变量。 父函数不能访问子函数的内部变量
          变量或者函数的作用范围。 一个函数或者一个变量是在哪里有效的
          一个函数先在函数内寻找变量。 找不到会找上一级。 在找不到在上一级寻找。直到全局寻找这个变量。
          每个函数运行的时候都会创建一个执行环境。 函数执行完后上下文环境会被销毁。函数内的变量也会被销毁。 闭包除外。
          当前执行上下文环境始终在作用域链的第一位
7: 垃圾回收机制
    1: 标记清楚
    2: 引用计数
8: 基本类型和引用类型
    基本类型: 简单数据 Boolean、 String、Number、undefined、null、Symbol(es6新增) 原始类型的变量直接保存原始值 。 可以直接复制
    引用类型: Object、 Array RegExp、 Function、Date,   保存指针, 不能直接复制
9: rel="preload"
