#### CSS
1: 重绘与回流 哪些属性不需要重绘 transform 不会引起回流、 回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。
2: less scss   
    less  不支持自定义函数。 要是想自定义函数需要引入less-plugin-functions、变量定义@开头 mixins写法为 .px2rem() 调用的到时候直接 .px2rem()调用
    scss 支持自定义函数  @function px2rem()  mixins写法为@mixins 调用的时候为@incloudes

3: style-loader less-loader
    less-loader 解析 less 语法
    css-loader  分析各文件之间的关系、合并成一段css文件
    style-loader 的作用是把css-loader 处理过的css样式插入heade中的style标签中

4: 布局 上下剧中 左右剧中 定位 是否脱离文档流
    【垂直居中】1: flex布局（aligin-items: center）
              2: table-cell、vertical-center:middle
5: flex 布局
    display:flex
    aligin-items: center 垂直居中
    justify-content: center 水平居中
    flex-direction: colmun/ colmun-reserve
6: 盒模型 
    一个盒模型是由content padding border margin 组成的
    box-sizing
    content-box
    border-box
7: hotcss 1px 布局
    1px: border-image border-show 使用伪元素 before after
    hotcss: 根据屏幕dpr 设置缩放比。 设置根结点html的font-size的大小  320 * 20 /320 以【320】为基准
    dpr 越大 根结点的font-size越大
8:两列布局、三列布局
    【浮动】【定位】【flex】【圣杯】【双飞翼】
9: will-change: transform;

10:  重绘和回流 【重点】
    浏览器渲染页面的过程
    html解构树 + css样式 = render tree => 绘制页面
    dom树里面包含了所有的标签: 包括隐藏的和js插入的
    【重绘】当元素样式、属性需要更新的时候而页面布局没有发生变化。只影响外观风格。 这个时候会发生重绘 （颜色、背景）
    【回流】当页面元素的位置,尺寸、布局或者隐藏/显示 发生变化的时候而需要重新构建。这就称为回流(reflow)。
    思考: 是不是可以这样理解, 只要页面布局没发生变化就不会触发回流。 
    回流肯定会重绘

    transform:translateZ(0) 将dom 设置成一个独立的图层。那么这个dom元素的重绘和回流的影响只会在本图层中。不会影响其他
    
    
#### JS基础
1:原型链 构造函数
2:作用域
3:闭包
4:深克隆
5:基本类型、引用类型
6:内存泄漏和垃圾回收
    【1】: 标记清除 常用
        运行时会给所有变量加标记、 标记进入环境了。 变量或者函数执行完后会标记离开环境
    【2】: 引用计数
    【】 全局变量会引起内存泄漏
7:变量声明提升
8:构造函数
9:对象、实例
10:作用域
11:new 运算符的执行过程
    var obj = {  }
        obj.__proto__ = fun.prototype
        fn.call(obj)    
12:null 和 undefined 的 区别
13:instanceof 原理
    instanceof 判断一个对象或者一个方法 来自哪个构造函数
    obj.__proto__ === Function.prototype
14:代码复用 继承 函数封装(一个函数完成一个简单的功能) 把做什么和怎么做分开 apply mixin
    柯里化
15: 继承、原形链继承
16: 类型转换
17: valueOf
19: 模块化
20: es6: import / export
    commonjs: require / module.exports / exports
    amd: require / defined
21: 防抖:将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可
22: 截流:每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可
23: this 指向问题
24: ast 语法数
25: babel编译原理
    babylon 将 ES6/ES7 代码解析成 AST
    babel-traverse 对 AST 进行遍历转译，得到新的 AST
    新 AST 通过 babel-generator 转换成 ES5
26: 函数柯里化
27: 数组 map filter forEach every sort reverse some slice splice split reduce  二维数组拍平
28: 输入url的整个过程
29: documentFragment
30: localStorage 、 sessionStorage cookie
31: 实现bind call apply

-----------------------------------------
   1:call apply bind
        解: 改变函数执行时候的上下文 或者说是改变this指向。 复用
        call(this, args1, args2, args3) // 会立即执行
        apply(this, [args1, args2, args3]) // 会立即执行
        bind(this)// 不会立即执行、 返回一个函数
   1:怎么利用call、apply来求一个数组中最大或者最小值
        Math.max.apply(Math, [2,43,31,45])
        Math.min.apply(Math, [2,43,31,45])
        Math.max.call(Math, ...[2,43,31,45])
        Math.min.call(Math, ...[2,43,31,45])
   2:如何利用call、apply来做继承
        构造函数继承
        Person.call(this)
   3:转化为伪数组
        Array.prototype.sclie.call(argsment)    
   4:数组追加
        [].push.apply(arr1, arr2)
   5: 检测类型
        Object.prototype.toSring.call()  '[object, Object]'
   3:apply、call、bind的区别和主要应用场景
2: Object.create
    /*
    * 复制对象到其原型上
    */
3: Object.assign(target, sources)
    /*
    * Object.assgin()
    * 浅克隆
    * 不会克隆继承过来的属性和方法
    * target为目标对象
    * sources为源对象
    */
4: Object.keys()  只遍历自身属性。hasOwnProperty只查找自身属性、不遍历原型链上到属性 for in 会遍历全部属性
5: valueOf, toSring 
    valueOf: 返回对象原始值的表示  *暂时还没理解太透彻
    toSring: 返回对象的字符串表示
    + 作为链接符的时候 会调用toString
    + 作为运算符的时候 会调用Number 转化然后相加 null undefined Boolean  会默认调用Number
      如果有一边确定为字符串的时候默认调用toString方法
6: 作用域和闭包
    闭包: 可以访问另一个函数内部变量
    作用域:子函数可以访问父函数的内部变量。 父函数不能访问子函数的内部变量
          变量或者函数的作用范围。 一个函数或者一个变量是在哪里有效的
          一个函数先在函数内寻找变量。 找不到会找上一级。 在找不到在上一级寻找。直到全局寻找这个变量。
          每个函数运行的时候都会创建一个执行环境。 函数执行完后上下文环境会被销毁。函数内的变量也会被销毁。 闭包除外。
          当前执行上下文环境始终在作用域链的第一位
7: 垃圾回收机制
    1: 标记清楚
    2: 引用计数
8: 基本类型和引用类型
    基本类型: 简单数据 Boolean、 String、Number、undefined、null、Symbol(es6新增) 原始类型的变量直接保存原始值 。 可以直接复制
    引用类型: Object、 Array RegExp、 Function、Date,   保存指针, 不能直接复制
9: rel="preload"

####  type of
type of null === object  可以从原形链的设计上说。 所有的对象原型都指向  Object.prototype.__proto__ = null
js 在底层储存变量的时候
000 代表对象而null全部用0表示



#### Vue
Vue: 归根结底他是一个对象!!! (构造函数)


1: 事件驱动

2: v-model的实现原理
    v-model 其实是个语法糖 v-bind:value v-on:input
    addProp(el, 'value', `(${value})`)
    addHandler(el, event, code, null, true)
    通过修改AST元素给el增加一个 props属性:value
    addHandler给el 增加一个处理事件 @input="input"
    data.props = {
        value: (message),
      }
    data.on = {
        input: function ($$v) {
          message=$$v
        }
      } 

3: Object.defineProperty(object, '')
4: vue中的数组方法 push pop shift unshift sort reverse  vue 通过原形拦截的方法对 这几个方法进行了重写，
5: nextTick
6: vue 中 组件的data 为什么必须是函数。 防止和其他实例公用data 属性
    data 要是是个对象的话。data上的值会被所有实例共享
    组册组件的实质就是建立一个组件构造引用。使用组件的时候才是真正创建一个组件的实例
7: keep-alive 实现原理和缓存策略
8: vue.extend()
9: vue.$set()  
    由于vue 会在初始化实例的时候把属性都变身响应式的
     执行getter setter 方法 set() 方法内部执行了defineReactive 
     用来给新加属性添加setter、getter 把它变成响应式
10: vue版本区别
   runtime-only: 只保留运行时需要。不承担模板编译工作 需要借助vue-loader去编译模板
   runtime-complier: 可以处理模板。承担编译工作
   $mount(el:'#app'): 挂载
   render函数:  有模板转换而来
   render 函数再转化为vnode 然后调用update函数更新视图
11: spa单页面的理解
   仅在页面初始化的时候加载 html js css 文件。
   一但页面加载完成spa 不会因为用户的操作而刷新页面。利用路由机制进行内容的更新
   优点: 体验好、比较快、避免页面刷新 重复跳转和
   缺点: 初次加载耗时比较多。 不能使用浏览器的前进 后退 可以使用$route.go()
   seo不友好
12: v-show 和 v-if的区别
    v-show 隐藏dom元素。display: none。不管条件是什么元素总会被渲染
    v-if: 移除dom元素。 会把条件块内的事件监听器和子组件适当的销毁。如果条件一开始就为false, 则什么也不做。true 的时候才会去渲染条件块内的元素渲染
13: 怎么理解vue的单项数据流
    数据只能有父组件向自组件传递。 不能有子组件向父组件传递。 prop 值在自组件内不允许被修改。
    自组件可以调用$emit向父组件派发一个自定义事件。父组件接受后由父组件进行修改。
14: computed watch 的区别。
    依赖其他值的变化计算生成新的值。有缓存、只有他的依赖值发生变化的时候 computed才会重新计算。
    watch 数据监听的回调。监听的值发生变化后执行回调进行业务操作。
15: vue对数组的操作
    push pop shift unshift reverse splice
16: vue 生命周期
17: $mount 做了哪些事情
18: keep-alive
    可以是被包含的组件保留状态(缓存)、避免重新渲染
    其实就是对被包在keep-alive里面的组件做了一个缓存
19: vue组件中的通信方式
    props $emit 父子通信
    $attrs $listeners 隔代通信
    $eventBus ($emit, $on) 父子、隔代、兄弟
    provide / inject  祖先组件通过provide 提供变量。子孙组件通过inject注入变量。主动提供和依赖注入
    vuex: 变量管理 父子、隔代、兄弟
20: vue-router的几种模式， vue-router的实现
      1:history hash abstract
      几种模式的区别:
      1:hash模式 路由中的# hash 虽然出现在url中 但是不会包括在请求中、对后端完全没有影响。 hash改变也不会重新加载页面
        通过监听hashchange 触发回调
        window.addEventListener('hashchange', function() {
            console.log('111')
        },false)
      2:history 模式 // 暂时还没弄太懂啊哥哥
        原理就是调用history.pushState
        跳转的时候监听popstate
21: require.context做自动化引入




#### vue-router
1: vue-router的几种模式mode history.go() history.back() history.pushState(null,
null, ) 1: hash #hash http请求中不会携带hash内容 对后端完全没有影响。
hash改变也不会重新加载页面 对hashchange监听 触发回调执行render函数
window.addEventListener('hashchange', function() { console.log('111') },false)
window.location.hash = path 方式切换路由 2: history 不怕前进不怕后退、就怕刷新
通过监听popstate 来触发回调 vue-router调用history.transitionTo切换路由
1:transitionTo中先用目标路径和当前路径进行匹配 2:然后调用confirmTransition方法
最后都会调用window.history.pushState(null, null, url) 来切换路由
3:vue-router的的组件切换工作是有view-router完成。 view-router 是一个vue-router
中的内置组件。 获取当前路由、然后匹配到当前路由对应的组件 通过render函数来渲染


#### webpack
1:webpack: 代码分割
【入口】【出口】【loader】【插件】
2:loader
    使webpack拥有解析非js文件的能力, plugin可以扩展webpack的功能。
    loader的作用就是提取、对不同格式的文件进行处理。
    vue-loader都是做了哪些事情?
    【1】解析.vue文件。提取出其中的style【样式】script template。交给他们对应的loader进行处理
     会把模板解析成render函数。 这一步是帮助vue提前做了编译工作。
3: amd cmd umd commonjs 
4: reuqire 和import
5: 天生不处理css 文件、 要想 处理css 就要添加 css-loader 和 style-loader
    css-loader去处理css 文件 style-loader 会把处理后的css 样式 插入到html head中
6: vue文件要经过vue-loader 处理 处理里面的模板、 style 和 script
    less 文件需要经过 less-loader css-loader处理。
    style-loader可以以style标签的形式插入html的heade。 
    MiniCssExtractPlugin可以帮助把样式提取出来放到一个css文件中引入
    MiniCssExtractPlugin只推荐生产环境用。开发环境会造成热更新失效
7: optimization 公共部分提取
    强大的SplitChunks
    webpack4 舍弃了之前的commonChunkPlugin。 commonChunkPlugin有哪些缺点
    optimization: {
        optimization: {
            chunks: 'async', // 默认只对按需加载的模块起作用。async|异步、 all|所用模块、 initial| 初始化加载的模块,即同步模块
            minSize: 30000, 模块大小, 只有超过这个数子参会被切割split
            maxSize: 默认值0，代表不限制。
            minChunks: 1, //module至少被多少chunk引用才会生成新chunk
        }
    }
    也可打包指定的less|scss|sass
8: mini-css-extract-plugin
    可以提取css样式
    用法: new MiniCssExtractPlugin({
        filename: [name].css
    })
    new MiniCssExtractPlugin({
        filename: [name].css,
        chunkFilename: '[name].min.[hash].css'
    })
9: webpack热更新
    hot: true
    模块热更新会在程序运行过程中替换、添加、或删除模块而无需刷新整个页面。
    保留页面状态
    只更新变更内容
    在源码中对css、js进行修改会立刻在浏览器中更新
    【1】webpack的文件监听机制
    【2】webpack启动过程中会调用Compiler类的run 方法开启构建过程。
10: webpack优化
    【1】尽量少使用三方依赖包 例如monent
    【2】按需引入依赖。 例如: lodash e-chart 等体积比较大的公有包 都是支持按需引入的。按需引入我们需要的模块。
    【3】优化resolve.extensions配置、设置解析文件后缀
    【4】优化loader配置。缩小匹配范围。通过 include exclude 来减少匹配文件
    【5】splitChunks  提取公共模块 
    【6】cache-loader
 

#### babel
babel7:

babel-loader + @babel/preset-env + @babel/polyfill + @babel/plugin-transform-runtime
【】@babel/preset-env 用来转化语法
    1: () => {} 箭头函数
    2: let const 
    3: export import 模块话
    4: 运算符扩展 ...arr ...obj
    5: 解构赋值 
        let [a,b,c] = [1,2,3]
        let { age } = { age: 56 }
    6: 默认参数
        function fun(params = {}) {

        }
    7: class extend
    8: 字符串模板
            `${str}ewew` => ''.concat('ewew')
【】@babel/polyfill 用来处理新的es6 api 
    当运行环境中不支持一些api时, polyfill 会引入一个相关的文件做兼容
    (垫片的方式在目标环境中添加缺失的特性)
    1: promise
    2: assigin includes every 
    3: Map Set Symbol 等全局对象
【】@babel/plugin-transform-runtime
    帮助函数, 引用他后帮助函数就会从@babel/runtime/helpers中引入。 从而优化我们的代码。 缩小打包体积



#### 事件循环
【1】js单线程 主线程、执行任务栈、 异步任务执行完毕后在任务队列里面放置一个事件
    还有微任务和宏任务之分
    【任务进入执行栈】 -> 主进程处理执行栈中的任务 -> 是否是同步进程 --> 同步进程压栈立即执行 -> 执行完毕出栈【释放上下文环境】->执行栈清空 -> 查看任务队列是否有新的事件需要执行-> 如果有则执行任务队列中的事件
    【微任务】promise、 process.nextTick
    【宏任务】setTimeout、 setInterval、 i/o操作。 dom点击触发的回调函数
    
    微任务比宏任务先执行
【2】node
    v8 引擎
    i/o处理自己设计了libuv, 基于事件驱动的跨平台抽象层
    v8 引擎解析js 脚本
    解析后的代码调用 nodeAPI
    libuv 负责api的执行、将不同的任务分给不同的线程、形成一个event loop 事件循环 已异步的方式将你任务执行结果返回给v8引擎
    v8 引擎将结果返回给用户
    总共分为6个阶段
    【外部数据输入】-> 【轮训阶段】 -> 检查阶段 -> 关闭事件回调阶段 -> 定时器检测阶段 -> i/o 事件回调阶段 -> 闲置阶段 -> 轮训阶段
  

#### http 报文的组成部分
【请求报文】
    请求行: 请求方法【get|post|options】/url【其实就是api】| 协议版本【http1.1 | http1.0】
    请求头部: request Header 【host】【content-type】【accpet】【User-Agent】
    空行 // 空行用来分割头部信息和请求体
    请求体 【参数】
【响应报文】
    响应行
    响应头部
    空行
    响应体
状态码:
    2xx
        status Code: 200  // 请求成功 请求被接受处理
        204: 服务器接受但是没content返回
    3xx
        301:永久重定向
        302:临时重定向
        303:临时重定向 使用get访问
        304: not modifiled  有缓存 【exporis】【cach-control】 | 【last-modifiled】【if-modifiled-since】 | 【etag】【if-none-match】 【强制缓存和协商缓存】
    4xx
        400: bad request 参数错误。 服务端无法理解
        401: 用户信息未验证 （未登陆）
        403: 服务端收到请求但拒绝提供服务
        404: 路径错误/请求资源不存在
    5xx
        500: 服务器错误
        503: 服务器不能处理当前请求
#### http的作用
【自我理解】
 http是客户端和服务端通信的桥梁。来帮助我们从客户端获取资源
 围绕这件事进行了许多优化。 提供一些参数来更好的做这件事。
 cookie或者token
 cookie: 储存用户信息 大小为4kb

 localStorage: 本地存贮、永久有效 除非手动清空 一般为5M
 sessionStorage: 具有会话作用域, 一般为5M

 http是无状态说的协议。 服务端需要验证我们的身份。 cookie 用来保存我们的身份信息。
 浏览器缓存策略
    contection: keep-alive
    accept 
    content-type
    accept-encodeing
    content-encodeing
    user-agent
    传输数据方面的优化
    http1.0 
        contection字段: keep-alive
        数据压缩 accept-encodeing
    http1.1
        默认keep-alive 【持久链接】
        管道机制: 一个链接里面可以发送多个请求。 但是服务端要挨个处理， 会阻塞
        分块传输编码: 流模式 Transfer-Encoding: chunked
            来一块处理一块。 每一块上有标记
从输入url到显示出页面要经多哪些过程
    url -> 域名解析(这个过程会一步步寻找域名对应的ip地址,) 
    -> 封装http数据包 
    -> tcp/ip 三次握手 
    -> 客户端发送请求
    -> 服务端响应请求 
    -> 关闭tcp/四次挥手
    -> 然后客户端获取html文件
    -> 开始解析头部style文件
    -> 获取link 和script标签中的资源 -> (是否使用缓存|是否有缓存) -> 再一次发送请求获取css js 资源。 然后css + dom = render tree > 渲染页面
https = http+ ssl
    就是比http层多了一个密钥层

http缺点：使用明文 ，内容容易被抓取
https 加密内容  不容易被抓取 通过一些加密算法对传输数据进行加密
tls/ssl 散列hash + 非对称加密+对称加密

#### http和https的区别是什么
【1】http是明文传输、 https经过了ssl层的加密
【2】http的端口是80、 https的默认端口是433
【3】https 证书需要费用
【4】对称加密是对内容进行加密 -> 产生一个密钥
    非对称加密是对 产生的密钥进行加密
    hash算法处理 公钥和个人信息 -> 形成加密串 然后和公有信息一起经过CA私钥进行加密 -> 数字签名


### tcp/ip 协议
第一次握手: SYN = 1 【标志位】seq = j 随机数 【发送给server】 【客户端进入等待状态】 【SYN_SENT态】
第二次握手: SYN = 1 ACK = 1 ack = j+1  seq = k 【服务端发送给客户端】 【服务端进入等待状态】
第三次握手: ACK = 1 seq = j+1 ack = k+1 【客户端发送给服务端】 三次握手之后建立链接
seq 是序列号
ack 确认号
ACK 确认字段 当ACK 为1 的时候确认号才有效
SYN: 当SYN =1 ACK = 0 是这是一个请求报文

SYN: 请求建立链接
ACK: 标志确认号ack是否有效
SYN ACK 表示标志位
seq ack 表示序列号


四次挥手 
1: FIN = 1  seq = u 【客户端发送】
2: ACK = 1  seq = v ack = u + 1  【服务端发送】
3: FIN = 1  ACK = 1 seq = w ack = u + 1 【服务端发送】
4: ACK = 1  seq = u + 1 ack = w + 1
为什么关闭链接要四次挥手
服务器接收到消息之后 可能不能立刻关闭链接。所以先发送一个ACK消息。 等链接关闭之后再给client发送一个FIN 告诉他我关闭了

网络协议的几层
1: 应用层 【http数据】【http首部】
2: 传输层 【tcp首部】
3: 网络层 【IP首部】
4: 链路层 【以太网首部】

#### axios
【1】axios: 基于promise封装的ajax请求
【2】支持浏览器和node端使用
【3】支持请求拦截和响应拦截
【4】支持请求取消 【concelToken】
    创建取消请求、一个promise,
    let source =  CancelToken.source: 创建一个取消令牌
    axios({
        CancelToken: source.token // token  是个promise 是CancelToken 实例
    })
    source.cancel执行的时候会把this.reason 为Cancel的一个实例
    如果不调用source.cancel() 则CancelToken.source().token 不会有reason属性
    source.cancel()一执行 ->  token.reason = new Cancel() 【reason】属性就会有值 -> 就会resolvePromise() -> 然后就会promise.then里面 去abort
【5】批量请求 axios.all
【6】安全性更高，客户端支持防御 XSRF
    就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，
    假冒的网站是拿不到你cookie中得key的
    这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，
    从而采取正确的策略。
xmlHttpRequest()
[1] onreadychangestate: 只要readyState 属性发生了变化就会调用次回调
【只要readyState】 
    0: 代理被创建, 但尚未调用open方法 【UNSENT】
    1: open 方法已经被调用  【OPENED】
    2: send方法已经被调用 【HEADERS_RECEIVED】
    3: 下载中 responseText 已经包含部分数据
    4: 下载操作已经完成 DONE


 
#### 安全
1: xss: 跨站脚本攻击
 httponly 禁止防止cookie 读取
 输入检查、 对输入值进行校验 主要是对特殊字符 < > & \n
2: crfs跨站请求伪造
    劫持受信任用户向服务端发送非预期的请求
    借助受害者的cookie 伪造信息骗取服务端的信任
    验证码
    referer check http 头部信息referer字段记录了http请求的来源地址


  
  